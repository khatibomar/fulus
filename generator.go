//go:build ignore

package main

import (
	"archive/zip"
	"bytes"
	"encoding/json"
	"encoding/xml"
	"fmt"
	"go/format"
	"io"
	"log"
	"net/http"
	"os"
	"path/filepath"
	"sort"
	"strconv"
	"strings"
	"text/template"
	"time"
	"unicode"
)

const (
	cldrRepoLatestReleaseURL = "https://api.github.com/repos/unicode-org/cldr-json/releases/latest"
	isoURL                   = "https://www.six-group.com/dam/download/financial-information/data-center/iso-currrency/lists/list-one.xml"
)

type Generator struct {
	CLDRVersion string
	Currencies  map[string]*CurrencyInfo
	Locales     map[string]*CurrencyFormatInfo // Changed from LocaleInfo to CurrencyFormatInfo
	tempDir     string
}

type CurrencyInfo struct {
	Code          string                         // ISO 4217 code (e.g., "USD")
	Number        string                         // ISO 4217 number (e.g., "840")
	Name          string                         // Official currency name
	MinorUnits    int                            // Number of decimal places
	DefaultSymbol string                         // Default symbol if no locale-specific one exists
	LocalizedInfo map[string]*CurrencyFormatInfo // Locale code -> Format info
	CLDRVersion   string                         // CLDR version used
	ISOLastUpdate string                         // ISO 4217 last update date
}

type CurrencyFormatInfo struct {
	Symbol           string // Currency symbol for this locale (e.g., "$" for USD in en-US)
	Format           string // Number format pattern (e.g., "#,##0.00 ¤")
	GroupSeparator   string // Thousands separator (e.g., "," in en-US)
	DecimalSeparator string // Decimal separator (e.g., "." in en-US)
	MinusSign        string // Negative number prefix (e.g., "-")
}

const localeTemplate = `// Code generated by generator.go; DO NOT EDIT.

package locale

// Locale represents a supported locale identifier
type Locale struct {
    code string
}

// Predefined supported locales
var (
    {{- range .}}
    {{.CodeVar}} = Locale{code: "{{.Code}}"}
    {{- end}}
)

// ParseLocale creates a Locale from a string, returns false if locale is not supported
func ParseLocale(code string) (Locale, bool) {
    switch code {
    {{- range .}}
    case "{{.Code}}":
        return {{.CodeVar}}, true
    {{- end}}
    default:
        return Locale{}, false
    }
}

// String returns the string representation of the locale
func (l Locale) String() string {
    return l.code
}
`

const currencyTemplate = `// Code generated by generator.go; DO NOT EDIT.

// CLDR Version: {{.CLDRVersion}}
// ISO 4217 Data Last Updated: {{.ISOLastUpdate}}

package currency

import "github.com/khatibomar/fulus/locale"

var _ Currency = {{.Code}}{}

// {{.Name}} currency type
type {{.Code}} struct{}

func ({{.Code}}) Code() string { return "{{.Code}}" }

func ({{.Code}}) Number() string { return "{{.Number}}" }

func ({{.Code}}) Name() string { return "{{.Name}}" }

func ({{.Code}}) MinorUnits() int { return {{.MinorUnits}} }

func ({{.Code}}) FormatInfo(localeType locale.Locale) CurrencyFormatInfo {
    switch localeType {
    {{- range $locale, $info := .LocalizedInfo}}
    case locale.{{toIdentifier $locale}}:
        return CurrencyFormatInfo{
            Symbol:           "{{$info.Symbol}}",
            Format:          "{{$info.Format}}",
            GroupSeparator:   "{{$info.GroupSeparator}}",
            DecimalSeparator: "{{$info.DecimalSeparator}}",
            MinusSign:        "{{$info.MinusSign}}",
        }
    {{- end}}
    default:
        return CurrencyFormatInfo{
            Symbol:           "{{.DefaultSymbol}}",
            Format:          "#,##0.00 ¤",
            GroupSeparator:   ",",
            DecimalSeparator: ".",
            MinusSign:        "-",
        }
    }
}
`

func main() {
	tempDir, err := os.MkdirTemp("", "fulus-generator-*")
	if err != nil {
		log.Fatal(err)
	}
	defer os.RemoveAll(tempDir)

	g := &Generator{
		Currencies: make(map[string]*CurrencyInfo),
		Locales:    make(map[string]*CurrencyFormatInfo),
		tempDir:    tempDir,
	}

	if err := g.fetchCLDR(); err != nil {
		log.Fatal(err)
	}

	if err := g.fetchISO(); err != nil {
		log.Fatal(err)
	}

	if err := g.processLocales(); err != nil {
		log.Fatal(err)
	}

	if err := g.generateLocales(); err != nil {
		log.Fatal(err)
	}

	if err := g.generateCurrencies(); err != nil {
		log.Fatal(err)
	}
}

func (g *Generator) fetchCLDR() error {
	log.Println("Fetching latest CLDR release info...")

	req, err := http.NewRequest("GET", cldrRepoLatestReleaseURL, nil)
	if err != nil {
		return fmt.Errorf("failed to create request: %w", err)
	}
	req.Header.Set("Accept", "application/vnd.github.v3+json")

	resp, err := http.DefaultClient.Do(req)
	if err != nil {
		return fmt.Errorf("failed to fetch release info: %w", err)
	}
	defer resp.Body.Close()

	var release struct {
		TagName string `json:"tag_name"`
		Assets  []struct {
			Name               string `json:"name"`
			BrowserDownloadURL string `json:"browser_download_url"`
		} `json:"assets"`
	}

	if err := json.NewDecoder(resp.Body).Decode(&release); err != nil {
		return fmt.Errorf("failed to decode release info: %w", err)
	}

	log.Printf("Latest CLDR version: %s", release.TagName)

	var zipURL string
	for _, asset := range release.Assets {
		if strings.HasSuffix(asset.Name, ".zip") {
			zipURL = asset.BrowserDownloadURL
			break
		}
	}

	if zipURL == "" {
		return fmt.Errorf("no zip file found in release %s", release.TagName)
	}

	log.Printf("Downloading CLDR data from %s...", zipURL)

	resp, err = http.Get(zipURL)
	if err != nil {
		return fmt.Errorf("failed to download zip: %w", err)
	}
	defer resp.Body.Close()

	tempDir, err := os.MkdirTemp("", "fulus-cldr-*")
	if err != nil {
		return fmt.Errorf("failed to create temp directory: %w", err)
	}
	g.tempDir = tempDir

	zipFile, err := os.CreateTemp("", "cldr-*.zip")
	if err != nil {
		return fmt.Errorf("failed to create temp zip file: %w", err)
	}
	defer os.Remove(zipFile.Name())
	defer zipFile.Close()

	if _, err := io.Copy(zipFile, resp.Body); err != nil {
		return fmt.Errorf("failed to save zip file: %w", err)
	}

	log.Println("Extracting CLDR data...")

	r, err := zip.OpenReader(zipFile.Name())
	if err != nil {
		return fmt.Errorf("failed to open zip file: %w", err)
	}
	defer r.Close()

	for _, f := range r.File {
		target := filepath.Join(tempDir, f.Name)

		if f.FileInfo().IsDir() {
			if err := os.MkdirAll(target, 0755); err != nil {
				return fmt.Errorf("failed to create directory %s: %w", target, err)
			}
			continue
		}

		if err := os.MkdirAll(filepath.Dir(target), 0755); err != nil {
			return fmt.Errorf("failed to create parent directory for %s: %w", target, err)
		}

		outFile, err := os.OpenFile(target, os.O_WRONLY|os.O_CREATE|os.O_TRUNC, f.Mode())
		if err != nil {
			return fmt.Errorf("failed to create file %s: %w", target, err)
		}

		rc, err := f.Open()
		if err != nil {
			outFile.Close()
			return fmt.Errorf("failed to open zip file entry %s: %w", f.Name, err)
		}

		if _, err := io.Copy(outFile, rc); err != nil {
			outFile.Close()
			rc.Close()
			return fmt.Errorf("failed to extract file %s: %w", f.Name, err)
		}

		outFile.Close()
		rc.Close()
	}

	g.CLDRVersion = release.TagName
	log.Printf("CLDR data extracted successfully")

	requiredDirs := []string{
		"cldr-numbers-full",
		"cldr-core",
		"cldr-dates-full",
	}

	for _, dir := range requiredDirs {
		if _, err := os.Stat(filepath.Join(g.tempDir, dir)); err != nil {
			return fmt.Errorf("required directory %s not found: %w", dir, err)
		}
	}

	return nil
}

func (g *Generator) fetchISO() error {
	log.Println("Fetching ISO currency data...")
	resp, err := http.Get(isoURL)
	if err != nil {
		return fmt.Errorf("fetchISO: %w", err)
	}
	defer resp.Body.Close()

	lastModified := resp.Header.Get("Last-Modified")
	if lastModified == "" {
		lastModified = time.Now().Format("2006-01-02")
	}

	data, err := io.ReadAll(resp.Body)
	if err != nil {
		return fmt.Errorf("fetchISO: %w", err)
	}

	type ISOEntry struct {
		Country    string `xml:"CtryNm"`
		Currency   string `xml:"CcyNm"`
		Code       string `xml:"Ccy"`
		Number     string `xml:"CcyNbr"`
		MinorUnits string `xml:"CcyMnrUnts"`
	}

	type ISOData struct {
		Entries []struct {
			Entry []ISOEntry `xml:"CcyNtry"`
		} `xml:"CcyTbl"`
	}

	var iso ISOData
	if err := xml.Unmarshal(data, &iso); err != nil {
		return fmt.Errorf("fetchISO: %w", err)
	}

	for _, table := range iso.Entries {
		for _, entry := range table.Entry {
			if entry.Code == "" || entry.Number == "" {
				continue
			}

			// Skip testing and special purpose codes
			if strings.HasPrefix(entry.Country, "ZZ") {
				continue
			}

			minorUnits := 2
			if entry.MinorUnits != "N.A." {
				if units, err := strconv.Atoi(entry.MinorUnits); err == nil {
					minorUnits = units
				}
			}

			if _, exists := g.Currencies[entry.Code]; !exists {
				g.Currencies[entry.Code] = &CurrencyInfo{
					Code:          entry.Code,
					Number:        entry.Number,
					Name:          entry.Currency,
					MinorUnits:    minorUnits,
					DefaultSymbol: entry.Code,
					LocalizedInfo: make(map[string]*CurrencyFormatInfo),
					CLDRVersion:   g.CLDRVersion,
					ISOLastUpdate: lastModified,
				}
			}
		}
	}

	log.Printf("Processed %d currencies", len(g.Currencies))
	return nil
}

func (g *Generator) processLocales() error {
	log.Println("Processing locales...")
	localesPath := filepath.Join(g.tempDir, "cldr-numbers-full", "main")
	entries, err := os.ReadDir(localesPath)
	if err != nil {
		return fmt.Errorf("failed to read locales directory: %w", err)
	}

	if g.Locales == nil {
		g.Locales = make(map[string]*CurrencyFormatInfo)
	}

	for _, entry := range entries {
		if !entry.IsDir() {
			continue
		}
		locale := entry.Name()
		log.Printf("Processing locale: %s", locale)

		numbersData, err := os.ReadFile(filepath.Join(localesPath, locale, "numbers.json"))
		if err != nil {
			log.Printf("Warning: couldn't read numbers.json for %s: %v", locale, err)
			continue
		}

		var numbersFile struct {
			Main map[string]struct {
				Numbers struct {
					Symbols struct {
						Decimal string `json:"decimal"`
						Group   string `json:"group"`
						Minus   string `json:"minusSign"`
					} `json:"symbols-numberSystem-latn"`
					CurrencyFormats struct {
						Standard string `json:"standard"`
					} `json:"currencyFormats-numberSystem-latn"`
				}
			}
		}

		if err := json.Unmarshal(numbersData, &numbersFile); err != nil {
			log.Printf("Warning: couldn't parse numbers.json for %s: %v", locale, err)
			continue
		}

		localeData := numbersFile.Main[locale].Numbers

		g.Locales[locale] = &CurrencyFormatInfo{
			Format:           cleanFormatCharacters(localeData.CurrencyFormats.Standard),
			GroupSeparator:   cleanFormatCharacters(localeData.Symbols.Group),
			DecimalSeparator: cleanFormatCharacters(localeData.Symbols.Decimal),
			MinusSign:        cleanFormatCharacters(localeData.Symbols.Minus),
		}

		currenciesData, err := os.ReadFile(filepath.Join(localesPath, locale, "currencies.json"))
		if err != nil {
			log.Printf("Warning: couldn't read currencies.json for %s: %v", locale, err)
			continue
		}

		var currenciesFile struct {
			Main map[string]struct {
				Numbers struct {
					Currencies map[string]struct {
						Symbol    string `json:"symbol"`
						SymbolAlt string `json:"symbol-alt-narrow,omitempty"`
					}
				}
			}
		}

		if err := json.Unmarshal(currenciesData, &currenciesFile); err != nil {
			log.Printf("Warning: couldn't parse currencies.json for %s: %v", locale, err)
			continue
		}

		for code, currencyData := range currenciesFile.Main[locale].Numbers.Currencies {
			if currency, exists := g.Currencies[code]; exists {
				symbol := currencyData.Symbol
				if symbol == "" {
					symbol = currencyData.SymbolAlt
					if symbol == "" {
						symbol = code
					}
				}

				symbol = cleanFormatCharacters(symbol)

				currency.LocalizedInfo[locale] = &CurrencyFormatInfo{
					Symbol:           symbol,
					Format:           g.Locales[locale].Format,
					GroupSeparator:   g.Locales[locale].GroupSeparator,
					DecimalSeparator: g.Locales[locale].DecimalSeparator,
					MinusSign:        g.Locales[locale].MinusSign,
				}

				if locale == "en" && currency.DefaultSymbol == code {
					currency.DefaultSymbol = symbol
				}
			}
		}
	}

	log.Printf("Processed %d locales", len(g.Locales))
	return nil
}

func (g *Generator) generateLocales() error {
	log.Println("Generating locale.go...")

	type localeData struct {
		Code    string
		CodeVar string
	}

	var locales []localeData

	for locale := range g.Locales {
		locales = append(locales, localeData{
			Code:    locale,
			CodeVar: toIdentifier(locale),
		})
	}

	sort.Slice(locales, func(i, j int) bool {
		return locales[i].Code < locales[j].Code
	})

	log.Printf("Generating locale.go with %d locales", len(locales))

	outDir := "locale"
	if err := os.MkdirAll(outDir, 0755); err != nil {
		return err
	}

	var buf bytes.Buffer
	if err := template.Must(template.New("locale").Parse(localeTemplate)).Execute(&buf, locales); err != nil {
		return fmt.Errorf("failed to execute template: %w", err)
	}

	formatted, err := format.Source(buf.Bytes())
	if err != nil {
		return fmt.Errorf("failed to format generated code: %w", err)
	}

	if err := os.WriteFile(filepath.Join(outDir, "gen_locale.go"), formatted, 0644); err != nil {
		return fmt.Errorf("failed to write locale.go: %w", err)
	}

	return nil
}

func (g *Generator) generateCurrencies() error {
	tmpl := template.Must(template.New("currency").Funcs(template.FuncMap{
		"toIdentifier": toIdentifier,
	}).Parse(currencyTemplate))

	outDir := "currency"
	if err := os.MkdirAll(outDir, 0755); err != nil {
		return err
	}

	for code, info := range g.Currencies {
		fileName := filepath.Join(outDir, "gen_"+strings.ToLower(code)+".go")

		var buf bytes.Buffer
		if err := tmpl.Execute(&buf, info); err != nil {
			return fmt.Errorf("failed to execute template for %s: %w", code, err)
		}

		formatted, err := format.Source(buf.Bytes())
		if err != nil {
			return fmt.Errorf("failed to format generated code for %s: %w", code, err)
		}

		if err := os.WriteFile(fileName, formatted, 0644); err != nil {
			return fmt.Errorf("failed to write %s: %w", fileName, err)
		}

		log.Printf("Generated %s", fileName)
	}

	return nil
}

func cleanFormatCharacters(s string) string {
	var result strings.Builder
	for _, r := range s {
		switch r {
		case '\u200b', '\u200e', '\u200f', '\u202a', '\u202b', '\u202c', '\u202d', '\u202e':
			result.WriteString(fmt.Sprintf("\\u%04x", r))
		default:
			result.WriteRune(r)
		}
	}
	return result.String()
}

func toIdentifier(code string) string {
	id := strings.ToUpper(strings.ReplaceAll(code, "-", "_"))
	if unicode.IsDigit(rune(id[0])) {
		id = "_" + id
	}
	return id
}
