# Fulus

![CI status](https://github.com/khatibomar/fulus/actions/workflows/main.yml/badge.svg)
[![GoDoc](https://godoc.org/github.com/khatibomar/fulus?status.png)](http://godoc.org/github.com/khatibomar/fulus)
[![Go Report](https://goreportcard.com/badge/github.com/khatibomar/fulus)](https://goreportcard.com/report/github.com/khatibomar/fulus)

<img src="https://github.com/user-attachments/assets/2b058650-0966-40e3-b629-fa6c3512bd46"/>

> Art generated by copilot

A Go library for handling monetary values and currency operations with type safety.

## Why?

### type safety

Money calculations require strict type safety to prevent costly mistakes. Fulus enforces this at compile time using Go generics:

```go
package main

import (
	"fmt"

	"github.com/khatibomar/fulus"
	"github.com/khatibomar/fulus/currency"
)

func main() {
	usd := fulus.NewMoney[currency.USD](1000) // $10.00
	eur := fulus.NewMoney[currency.EUR](500)  // ‚Ç¨5.00

	// This will not compile. compiler will throw this error.
	// cannot use eur (variable of struct type fulus.Money[currency.EUR]) 
	// as fulus.Money[currency.USD] value in argument to usd.Add
	// usd.Add(eur)

	ratio := fulus.Ratio{
		Numerator:   107203, // 1.07203 represented as 107203/100000
		Denominator: 100000,
	}
	eurInUsd, _, err := fulus.Convert[currency.EUR, currency.USD](eur, ratio)
	if err != nil {
		// handle error
	}
	usd, err = usd.Add(eurInUsd)
	if err != nil {
		// handle error
	}
	fmt.Println(usd) // $15.36
}
```

This prevents common mistakes like:
- Accidentally mixing different currencies in calculations
- Using floating point numbers for money (uses int64 internally)
- Imprecise currency conversions

### defining own currency types

Don't see your currency in the list? No problem! You can easily create custom currency types that are specific to your financial domain's needs.

Let's introduce kanna currency.

```go
package main

import (
	"fmt"

	"github.com/khatibomar/fulus"
	"github.com/khatibomar/fulus/currency"
)

var _ currency.Currency = KANNA{}

type KANNA struct{}

func (k KANNA) Code() string { return "KANNA" }

func (k KANNA) MinorUnitName() string { return "kanna" }

func (k KANNA) MinorUnitSymbol() string { return "üê≤" }

func (k KANNA) MinorUnits() int { return 2 }

func (k KANNA) Name() string { return "Kanna Kamui" }

func (k KANNA) Number() string { return "001" }

func (k KANNA) Symbol() string { return "üêâ" }

func main() {
	kanna := fulus.NewMoney[KANNA](1000)
	fmt.Println(kanna) // üêâ10.00
	kanna, _ = kanna.Mul(2)
	fmt.Println(kanna) // üêâ20.00
}
```

## Features

- Type-safe money operations using Go generics
- Prevention of invalid currency operations at compile time
- Safe decimal arithmetic using integer math
- Support for distribution and allocation of money
- JSON marshaling/unmarshaling support

## Credits

This library was inspired by the blog post [How to deal with Money in Software](https://cs-syd.eu/posts/2022-08-22-how-to-deal-with-money-in-software) by Christian Sejersen.
